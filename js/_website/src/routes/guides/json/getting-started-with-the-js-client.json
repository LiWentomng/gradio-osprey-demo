{"guide": {"name": "getting-started-with-the-js-client", "category": "client-libraries", "pretty_category": "Client Libraries", "guide_index": 2, "absolute_index": 27, "pretty_name": "Getting Started With The Js Client", "content": "# Getting Started with the Gradio JavaScript client\n\nTags: CLIENT, API, SPACES\n\nThe Gradio JavaScript client makes it very easy to use any Gradio app as an API. As an example, consider this [Hugging Face Space that transcribes audio files](https://huggingface.co/spaces/abidlabs/whisper) that are recorded from the microphone.\n\n![](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/gradio-guides/whisper-screenshot.jpg)\n\nUsing the `@gradio/client` library, we can easily use the Gradio as an API to transcribe audio files programmatically.\n\nHere's the entire code to do it:\n\n```js\nimport { client } from \"@gradio/client\";\n\nconst response = await fetch(\n  \"https://github.com/audio-samples/audio-samples.github.io/raw/master/samples/wav/ted_speakers/SalmanKhan/sample-1.wav\"\n);\nconst audio_file = await response.blob();\n\nconst app = await client(\"abidlabs/whisper\");\nconst transcription = await app.predict(\"/predict\", [audio_file]);\n\nconsole.log(transcription.data);\n// [ \"I said the same phrase 30 times.\" ]\n```\n\nThe Gradio client works with any hosted Gradio app, whether it be an image generator, a text summarizer, a stateful chatbot, a tax calculator, or anything else! The Gradio Client is mostly used with apps hosted on [Hugging Face Spaces](https://hf.space), but your app can be hosted anywhere, such as your own server.\n\n**Prequisites**: To use the Gradio client, you do _not_ need to know the `gradio` library in great detail. However, it is helpful to have general familiarity with Gradio's concepts of input and output components.\n\n## Installation\n\nThe lightweight `@gradio/client` package can be installed from the npm registry with a package manager of your choice and support node version 18 and above:\n\n```bash\nnpm i @gradio/client\n```\n\n## Connecting to a running Gradio App\n\nStart by connecting instantiating a `client` instance and connecting it to a Gradio app that is running on Hugging Face Spaces or generally anywhere on the web.\n\n## Connecting to a Hugging Face Space\n\n```js\nimport { client } from \"@gradio/client\";\n\nconst app = client(\"abidlabs/en2fr\"); // a Space that translates from English to French\n```\n\nYou can also connect to private Spaces by passing in your HF token with the `hf_token` property of the options parameter. You can get your HF token here: https://huggingface.co/settings/tokens\n\n```js\nimport { client } from \"@gradio/client\";\n\nconst app = client(\"abidlabs/my-private-space\", { hf_token=\"hf_...\" })\n```\n\n## Duplicating a Space for private use\n\nWhile you can use any public Space as an API, you may get rate limited by Hugging Face if you make too many requests. For unlimited usage of a Space, simply duplicate the Space to create a private Space, and then use it to make as many requests as you'd like!\n\nThe `@gradio/client` exports another function, `duplicate`, to make this process simple (you'll need to pass in your [Hugging Face token](https://huggingface.co/settings/tokens)).\n\n`duplicate` is almost identical to `client`, the only difference is under the hood:\n\n```js\nimport { client } from \"@gradio/client\";\n\nconst response = await fetch(\n  \"https://audio-samples.github.io/samples/mp3/blizzard_unconditional/sample-0.mp3\"\n);\nconst audio_file = await response.blob();\n\nconst app = await duplicate(\"abidlabs/whisper\", { hf_token: \"hf_...\" });\nconst transcription = app.predict(\"/predict\", [audio_file]);\n```\n\nIf you have previously duplicated a Space, re-running `duplicate` will _not_ create a new Space. Instead, the client will attach to the previously-created Space. So it is safe to re-run the `duplicate` method multiple times with the same space.\n\n**Note:** if the original Space uses GPUs, your private Space will as well, and your Hugging Face account will get billed based on the price of the GPU. To minimize charges, your Space will automatically go to sleep after 5 minutes of inactivity. You can also set the hardware using the `hardware` and `timeout` properties of `duplicate`'s options object like this:\n\n```js\nimport { client } from \"@gradio/client\";\n\nconst app = await duplicate(\"abidlabs/whisper\", {\n  hf_token: \"hf_...\",\n  timeout: 60,\n  hardware: \"a10g-small\",\n});\n```\n\n## Connecting a general Gradio app\n\nIf your app is running somewhere else, just provide the full URL instead, including the \"http://\" or \"https://\". Here's an example of making predictions to a Gradio app that is running on a share URL:\n\n```js\nimport { client } from \"@gradio/client\";\n\nconst app = client(\"https://bec81a83-5b5c-471e.gradio.live\");\n```\n\n## Inspecting the API endpoints\n\nOnce you have connected to a Gradio app, you can view the APIs that are available to you by calling the `client`'s `view_api` method.\n\nFor the Whisper Space, we can do this:\n\n```js\nimport { client } from \"@gradio/client\";\n\nconst app = await client(\"abidlabs/whisper\");\n\nconst app_info = await app.view_info();\n\nconsole.log(app_info);\n```\n\nAnd we will see the following:\n\n```json\n{\n  \"named_endpoints\": {\n    \"/predict\": {\n      \"parameters\": [\n        {\n          \"label\": \"text\",\n          \"component\": \"Textbox\",\n          \"type\": \"string\"\n        }\n      ],\n      \"returns\": [\n        {\n          \"label\": \"output\",\n          \"component\": \"Textbox\",\n          \"type\": \"string\"\n        }\n      ]\n    }\n  },\n  \"unnamed_endpoints\": {}\n}\n```\n\nThis shows us that we have 1 API endpoint in this space, and shows us how to use the API endpoint to make a prediction: we should call the `.predict()` method (which we will explore below), providing a parameter `input_audio` of type `string`, which is a url to a file.\n\nWe should also provide the `api_name='/predict'` argument to the `predict()` method. Although this isn't necessary if a Gradio app has only 1 named endpoint, it does allow us to call different endpoints in a single app if they are available. If an app has unnamed API endpoints, these can also be displayed by running `.view_api(all_endpoints=True)`.\n\n## Making a prediction\n\nThe simplest way to make a prediction is simply to call the `.predict()` method with the appropriate arguments:\n\n```js\nimport { client } from \"@gradio/client\";\n\nconst app = await client(\"abidlabs/en2fr\");\nconst result = await app.predict(\"/predict\", [\"Hello\"]);\n```\n\nIf there are multiple parameters, then you should pass them as an array to `.predict()`, like this:\n\n```js\nimport { client } from \"@gradio/client\";\n\nconst app = await client(\"gradio/calculator\");\nconst result = await app.predict(\"/predict\", [4, \"add\", 5]);\n```\n\nFor certain inputs, such as images, you should pass in a `Buffer`, `Blob` or `File` depending on what is most convenient. In node, this would be a `Buffer` or `Blob`; in a browser environment, this would be a `Blob` or `File`.\n\n```js\nimport { client } from \"@gradio/client\";\n\nconst response = await fetch(\n  \"https://audio-samples.github.io/samples/mp3/blizzard_unconditional/sample-0.mp3\"\n);\nconst audio_file = await response.blob();\n\nconst app = await client(\"abidlabs/whisper\");\nconst result = await client.predict(\"/predict\", [audio_file]);\n```\n\n## Using events\n\nIf the API you are working with can return results over time, or you wish to access information about the status of a job, you can use the event interface for more flexibility. This is especially useful for iterative endpoints or generator endpoints that will produce a series of values over time as discreet responses.\n\n```js\nimport { client } from \"@gradio/client\";\n\nfunction log_result(payload) {\n  const {\n    data: [translation],\n  } = payload;\n\n  console.log(`The translated result is: ${translation}`);\n}\n\nconst app = await client(\"abidlabs/en2fr\");\nconst job = app.submit(\"/predict\", [\"Hello\"]);\n\njob.on(\"data\", log_result);\n```\n\n## Status\n\nThe event interface also allows you to get the status of the running job by listening to the `\"status\"` event. This returns an object with the following attributes: `status` (a human readbale status of the current job, `\"pending\" | \"generating\" | \"complete\" | \"error\"`), `code` (the detailed gradio code for the job), `position` (the current position of this job in the queue), `queue_size` (the total queue size), `eta` (estimated time this job will complete), `success` (a boolean representing whether the job completed successfully), and `time` ( as `Date` object detailing the time that the status was generated).\n\n```js\nimport { client } from \"@gradio/client\";\n\nfunction log_status(status) {\n  console.log(\n    `The current status for this job is: ${JSON.stringify(status, null, 2)}.`\n  );\n}\n\nconst app = await client(\"abidlabs/en2fr\");\nconst job = app.submit(\"/predict\", [\"Hello\"]);\n\njob.on(\"status\", log_status);\n```\n\n## Cancelling Jobs\n\nThe job instance also has a `.cancel()` method that cancels jobs that have been queued but not started. For example, if you run:\n\n```js\nimport { client } from \"@gradio/client\";\n\nconst app = await client(\"abidlabs/en2fr\");\nconst job_one = app.submit(\"/predict\", [\"Hello\"]);\nconst job_two = app.submit(\"/predict\", [\"Friends\"]);\n\njob_one.cancel();\njob_two.cancel();\n```\n\nIf the first job has started processing, then it will not be canceled but the client will no longer listen for updates (throwing away the job). If the second job has not yet started, it will be successfully canceled and removed from the queue.\n\n## Generator Endpoints\n\nSome Gradio API endpoints do not return a single value, rather they return a series of values. You can listen for these values in real time using the event interface:\n\n```js\nimport { client } from \"@gradio/client\";\n\nconst app = await client(\"gradio/count_generator\");\nconst job = app.submit(0, [9]);\n\njob.on(\"data\", (data) => console.log(data));\n```\n\nThis will log out the values as they are generated by the endpoint.\n\nYou can also cancel jobs that that have iterative outputs, in which case the job will finish immediately.\n\n```js\nimport { client } from \"@gradio/client\";\n\nconst app = await client(\"gradio/count_generator\");\nconst job = app.submit(0, [9]);\n\njob.on(\"data\", (data) => console.log(data));\n\nsetTimeout(() => {\n  job.cancel();\n}, 3000);\n```\n", "html": "<h1 id=\"getting-started-with-the-gradio-javascript-client\">Getting Started with the Gradio JavaScript client</h1>\n\n<p>The Gradio JavaScript client makes it very easy to use any Gradio app as an API. As an example, consider this <a rel=\"noopener\" target=\"_blank\" href=\"https://huggingface.co/spaces/abidlabs/whisper\">Hugging Face Space that transcribes audio files</a> that are recorded from the microphone.</p>\n\n<p><img src=\"https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/gradio-guides/whisper-screenshot.jpg\" alt=\"\" /></p>\n\n<p>Using the <code>@gradio/client</code> library, we can easily use the Gradio as an API to transcribe audio files programmatically.</p>\n\n<p>Here's the entire code to do it:</p>\n\n<div class='codeblock'><pre><code class='lang-js'>import { client } from \"@gradio/client\";\n\nconst response = await fetch(\n  \"https://github.com/audio-samples/audio-samples.github.io/raw/master/samples/wav/ted_speakers/SalmanKhan/sample-1.wav\"\n);\nconst audio_file = await response.blob();\n\nconst app = await client(\"abidlabs/whisper\");\nconst transcription = await app.predict(\"/predict\", [audio_file]);\n\nconsole.log(transcription.data);\n// [ \"I said the same phrase 30 times.\" ]\n</code></pre></div>\n\n<p>The Gradio client works with any hosted Gradio app, whether it be an image generator, a text summarizer, a stateful chatbot, a tax calculator, or anything else! The Gradio Client is mostly used with apps hosted on <a rel=\"noopener\" target=\"_blank\" href=\"https://hf.space\">Hugging Face Spaces</a>, but your app can be hosted anywhere, such as your own server.</p>\n\n<p><strong>Prequisites</strong>: To use the Gradio client, you do <em>not</em> need to know the <code>gradio</code> library in great detail. However, it is helpful to have general familiarity with Gradio's concepts of input and output components.</p>\n\n<h2 id=\"installation\">Installation</h2>\n\n<p>The lightweight <code>@gradio/client</code> package can be installed from the npm registry with a package manager of your choice and support node version 18 and above:</p>\n\n<div class='codeblock'><pre><code class='lang-bash'>npm i @gradio/client\n</code></pre></div>\n\n<h2 id=\"connecting-to-a-running-gradio-app\">Connecting to a running Gradio App</h2>\n\n<p>Start by connecting instantiating a <code>client</code> instance and connecting it to a Gradio app that is running on Hugging Face Spaces or generally anywhere on the web.</p>\n\n<h2 id=\"connecting-to-a-hugging-face-space\">Connecting to a Hugging Face Space</h2>\n\n<div class='codeblock'><pre><code class='lang-js'>import { client } from \"@gradio/client\";\n\nconst app = client(\"abidlabs/en2fr\"); // a Space that translates from English to French\n</code></pre></div>\n\n<p>You can also connect to private Spaces by passing in your HF token with the <code>hf_token</code> property of the options parameter. You can get your HF token here: https://huggingface.co/settings/tokens</p>\n\n<div class='codeblock'><pre><code class='lang-js'>import { client } from \"@gradio/client\";\n\nconst app = client(\"abidlabs/my-private-space\", { hf_token=\"hf_...\" })\n</code></pre></div>\n\n<h2 id=\"duplicating-a-space-for-private-use\">Duplicating a Space for private use</h2>\n\n<p>While you can use any public Space as an API, you may get rate limited by Hugging Face if you make too many requests. For unlimited usage of a Space, simply duplicate the Space to create a private Space, and then use it to make as many requests as you'd like!</p>\n\n<p>The <code>@gradio/client</code> exports another function, <code>duplicate</code>, to make this process simple (you'll need to pass in your <a rel=\"noopener\" target=\"_blank\" href=\"https://huggingface.co/settings/tokens\">Hugging Face token</a>).</p>\n\n<p><code>duplicate</code> is almost identical to <code>client</code>, the only difference is under the hood:</p>\n\n<div class='codeblock'><pre><code class='lang-js'>import { client } from \"@gradio/client\";\n\nconst response = await fetch(\n  \"https://audio-samples.github.io/samples/mp3/blizzard_unconditional/sample-0.mp3\"\n);\nconst audio_file = await response.blob();\n\nconst app = await duplicate(\"abidlabs/whisper\", { hf_token: \"hf_...\" });\nconst transcription = app.predict(\"/predict\", [audio_file]);\n</code></pre></div>\n\n<p>If you have previously duplicated a Space, re-running <code>duplicate</code> will <em>not</em> create a new Space. Instead, the client will attach to the previously-created Space. So it is safe to re-run the <code>duplicate</code> method multiple times with the same space.</p>\n\n<p><strong>Note:</strong> if the original Space uses GPUs, your private Space will as well, and your Hugging Face account will get billed based on the price of the GPU. To minimize charges, your Space will automatically go to sleep after 5 minutes of inactivity. You can also set the hardware using the <code>hardware</code> and <code>timeout</code> properties of <code>duplicate</code>'s options object like this:</p>\n\n<div class='codeblock'><pre><code class='lang-js'>import { client } from \"@gradio/client\";\n\nconst app = await duplicate(\"abidlabs/whisper\", {\n  hf_token: \"hf_...\",\n  timeout: 60,\n  hardware: \"a10g-small\",\n});\n</code></pre></div>\n\n<h2 id=\"connecting-a-general-gradio-app\">Connecting a general Gradio app</h2>\n\n<p>If your app is running somewhere else, just provide the full URL instead, including the \"http://\" or \"https://\". Here's an example of making predictions to a Gradio app that is running on a share URL:</p>\n\n<div class='codeblock'><pre><code class='lang-js'>import { client } from \"@gradio/client\";\n\nconst app = client(\"https://bec81a83-5b5c-471e.gradio.live\");\n</code></pre></div>\n\n<h2 id=\"inspecting-the-api-endpoints\">Inspecting the API endpoints</h2>\n\n<p>Once you have connected to a Gradio app, you can view the APIs that are available to you by calling the <code>client</code>'s <code>view_api</code> method.</p>\n\n<p>For the Whisper Space, we can do this:</p>\n\n<div class='codeblock'><pre><code class='lang-js'>import { client } from \"@gradio/client\";\n\nconst app = await client(\"abidlabs/whisper\");\n\nconst app_info = await app.view_info();\n\nconsole.log(app_info);\n</code></pre></div>\n\n<p>And we will see the following:</p>\n\n<div class='codeblock'><pre><code class='lang-json'>{\n  \"named_endpoints\": {\n    \"/predict\": {\n      \"parameters\": [\n        {\n          \"label\": \"text\",\n          \"component\": \"Textbox\",\n          \"type\": \"string\"\n        }\n      ],\n      \"returns\": [\n        {\n          \"label\": \"output\",\n          \"component\": \"Textbox\",\n          \"type\": \"string\"\n        }\n      ]\n    }\n  },\n  \"unnamed_endpoints\": {}\n}\n</code></pre></div>\n\n<p>This shows us that we have 1 API endpoint in this space, and shows us how to use the API endpoint to make a prediction: we should call the <code>.predict()</code> method (which we will explore below), providing a parameter <code>input_audio</code> of type <code>string</code>, which is a url to a file.</p>\n\n<p>We should also provide the <code>api_name='/predict'</code> argument to the <code>predict()</code> method. Although this isn't necessary if a Gradio app has only 1 named endpoint, it does allow us to call different endpoints in a single app if they are available. If an app has unnamed API endpoints, these can also be displayed by running <code>.view_api(all_endpoints=True)</code>.</p>\n\n<h2 id=\"making-a-prediction\">Making a prediction</h2>\n\n<p>The simplest way to make a prediction is simply to call the <code>.predict()</code> method with the appropriate arguments:</p>\n\n<div class='codeblock'><pre><code class='lang-js'>import { client } from \"@gradio/client\";\n\nconst app = await client(\"abidlabs/en2fr\");\nconst result = await app.predict(\"/predict\", [\"Hello\"]);\n</code></pre></div>\n\n<p>If there are multiple parameters, then you should pass them as an array to <code>.predict()</code>, like this:</p>\n\n<div class='codeblock'><pre><code class='lang-js'>import { client } from \"@gradio/client\";\n\nconst app = await client(\"gradio/calculator\");\nconst result = await app.predict(\"/predict\", [4, \"add\", 5]);\n</code></pre></div>\n\n<p>For certain inputs, such as images, you should pass in a <code>Buffer</code>, <code>Blob</code> or <code>File</code> depending on what is most convenient. In node, this would be a <code>Buffer</code> or <code>Blob</code>; in a browser environment, this would be a <code>Blob</code> or <code>File</code>.</p>\n\n<div class='codeblock'><pre><code class='lang-js'>import { client } from \"@gradio/client\";\n\nconst response = await fetch(\n  \"https://audio-samples.github.io/samples/mp3/blizzard_unconditional/sample-0.mp3\"\n);\nconst audio_file = await response.blob();\n\nconst app = await client(\"abidlabs/whisper\");\nconst result = await client.predict(\"/predict\", [audio_file]);\n</code></pre></div>\n\n<h2 id=\"using-events\">Using events</h2>\n\n<p>If the API you are working with can return results over time, or you wish to access information about the status of a job, you can use the event interface for more flexibility. This is especially useful for iterative endpoints or generator endpoints that will produce a series of values over time as discreet responses.</p>\n\n<div class='codeblock'><pre><code class='lang-js'>import { client } from \"@gradio/client\";\n\nfunction log_result(payload) {\n  const {\n    data: [translation],\n  } = payload;\n\n  console.log(`The translated result is: ${translation}`);\n}\n\nconst app = await client(\"abidlabs/en2fr\");\nconst job = app.submit(\"/predict\", [\"Hello\"]);\n\njob.on(\"data\", log_result);\n</code></pre></div>\n\n<h2 id=\"status\">Status</h2>\n\n<p>The event interface also allows you to get the status of the running job by listening to the <code>\"status\"</code> event. This returns an object with the following attributes: <code>status</code> (a human readbale status of the current job, <code>\"pending\" | \"generating\" | \"complete\" | \"error\"</code>), <code>code</code> (the detailed gradio code for the job), <code>position</code> (the current position of this job in the queue), <code>queue_size</code> (the total queue size), <code>eta</code> (estimated time this job will complete), <code>success</code> (a boolean representing whether the job completed successfully), and <code>time</code> ( as <code>Date</code> object detailing the time that the status was generated).</p>\n\n<div class='codeblock'><pre><code class='lang-js'>import { client } from \"@gradio/client\";\n\nfunction log_status(status) {\n  console.log(\n    `The current status for this job is: ${JSON.stringify(status, null, 2)}.`\n  );\n}\n\nconst app = await client(\"abidlabs/en2fr\");\nconst job = app.submit(\"/predict\", [\"Hello\"]);\n\njob.on(\"status\", log_status);\n</code></pre></div>\n\n<h2 id=\"cancelling-jobs\">Cancelling Jobs</h2>\n\n<p>The job instance also has a <code>.cancel()</code> method that cancels jobs that have been queued but not started. For example, if you run:</p>\n\n<div class='codeblock'><pre><code class='lang-js'>import { client } from \"@gradio/client\";\n\nconst app = await client(\"abidlabs/en2fr\");\nconst job_one = app.submit(\"/predict\", [\"Hello\"]);\nconst job_two = app.submit(\"/predict\", [\"Friends\"]);\n\njob_one.cancel();\njob_two.cancel();\n</code></pre></div>\n\n<p>If the first job has started processing, then it will not be canceled but the client will no longer listen for updates (throwing away the job). If the second job has not yet started, it will be successfully canceled and removed from the queue.</p>\n\n<h2 id=\"generator-endpoints\">Generator Endpoints</h2>\n\n<p>Some Gradio API endpoints do not return a single value, rather they return a series of values. You can listen for these values in real time using the event interface:</p>\n\n<div class='codeblock'><pre><code class='lang-js'>import { client } from \"@gradio/client\";\n\nconst app = await client(\"gradio/count_generator\");\nconst job = app.submit(0, [9]);\n\njob.on(\"data\", (data) => console.log(data));\n</code></pre></div>\n\n<p>This will log out the values as they are generated by the endpoint.</p>\n\n<p>You can also cancel jobs that that have iterative outputs, in which case the job will finish immediately.</p>\n\n<div class='codeblock'><pre><code class='lang-js'>import { client } from \"@gradio/client\";\n\nconst app = await client(\"gradio/count_generator\");\nconst job = app.submit(0, [9]);\n\njob.on(\"data\", (data) => console.log(data));\n\nsetTimeout(() => {\n  job.cancel();\n}, 3000);\n</code></pre></div>\n", "tags": ["CLIENT", "API", "SPACES"], "spaces": [], "url": "/guides/getting-started-with-the-js-client/", "contributor": null}}