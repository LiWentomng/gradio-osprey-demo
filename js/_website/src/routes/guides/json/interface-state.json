{"guide": {"name": "interface-state", "category": "building-interfaces", "pretty_category": "Building Interfaces", "guide_index": 1, "absolute_index": 3, "pretty_name": "Interface State", "content": "# Interface State\n\nThis guide covers how State is handled in Gradio. Learn the difference between Global and Session states, and how to use both.\n\n## Global State\n\nYour function may use data that persists beyond a single function call. If the data is something accessible to all function calls and all users, you can create a variable outside the function call and access it inside the function. For example, you may load a large model outside the function and use it inside the function so that every function call does not need to reload the model. \n\n```python\nimport gradio as gr\n\nscores = []\n\ndef track_score(score):\n    scores.append(score)\n    top_scores = sorted(scores, reverse=True)[:3]\n    return top_scores\n\ndemo = gr.Interface(\n    track_score, \n    gr.Number(label=\"Score\"), \n    gr.JSON(label=\"Top Scores\")\n)\ndemo.launch()\n```\n\nIn the code above, the `scores` array is shared between all users. If multiple users are accessing this demo, their scores will all be added to the same list, and the returned top 3 scores will be collected from this shared reference. \n\n## Session State\n\nAnother type of data persistence Gradio supports is session **state**, where data persists across multiple submits within a page session. However, data is *not* shared between different users of your model. To store data in a session state, you need to do three things:\n\n1. Pass in an extra parameter into your function, which represents the state of the interface.\n2. At the end of the function, return the updated value of the state as an extra return value.\n3. Add the `'state'` input and `'state'` output components when creating your `Interface`\n\nA chatbot is an example where you would need session state - you want access to a users previous submissions, but you cannot store chat history in a global variable, because then chat history would get jumbled between different users. \n\n```python\nimport gradio as gr\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\nimport torch\n\ntokenizer = AutoTokenizer.from_pretrained(\"microsoft/DialoGPT-medium\")\nmodel = AutoModelForCausalLM.from_pretrained(\"microsoft/DialoGPT-medium\")\n\n\ndef user(message, history):\n    return \"\", history + [[message, None]]\n\n\ndef bot(history):\n    user_message = history[-1][0]\n    new_user_input_ids = tokenizer.encode(\n        user_message + tokenizer.eos_token, return_tensors=\"pt\"\n    )\n\n    # append the new user input tokens to the chat history\n    bot_input_ids = torch.cat([torch.LongTensor([]), new_user_input_ids], dim=-1)\n\n    # generate a response\n    response = model.generate(\n        bot_input_ids, max_length=1000, pad_token_id=tokenizer.eos_token_id\n    ).tolist()\n\n    # convert the tokens to text, and then split the responses into lines\n    response = tokenizer.decode(response[0]).split(\"<|endoftext|>\")\n    response = [\n        (response[i], response[i + 1]) for i in range(0, len(response) - 1, 2)\n    ]  # convert to tuples of list\n    history[-1] = response[0]\n    return history\n\n\nwith gr.Blocks() as demo:\n    chatbot = gr.Chatbot()\n    msg = gr.Textbox()\n    clear = gr.Button(\"Clear\")\n\n    msg.submit(user, [msg, chatbot], [msg, chatbot], queue=False).then(\n        bot, chatbot, chatbot\n    )\n    clear.click(lambda: None, None, chatbot, queue=False)\n\ndemo.launch()\n\n```\n<gradio-app space='gradio/chatbot_dialogpt'></gradio-app>\n\nNotice how the state persists across submits within each page, but if you load this demo in another tab (or refresh the page), the demos will not share chat history. \n\nThe default value of `state` is None. If you pass a default value to the state parameter of the function, it is used as the default value of the state instead. The `Interface` class only supports a single input and outputs state variable, though it can be a list with multiple elements. For more complex use cases, you can use Blocks, [which supports multiple `State` variables](/guides/state-in-blocks/).", "html": "<h1 id=\"interface-state\">Interface State</h1>\n\n<p>This guide covers how State is handled in Gradio. Learn the difference between Global and Session states, and how to use both.</p>\n\n<h2 id=\"global-state\">Global State</h2>\n\n<p>Your function may use data that persists beyond a single function call. If the data is something accessible to all function calls and all users, you can create a variable outside the function call and access it inside the function. For example, you may load a large model outside the function and use it inside the function so that every function call does not need to reload the model. </p>\n\n<div class='codeblock'><pre><code class='lang-python'>import gradio as gr\n\nscores = []\n\ndef track_score(score):\n    scores.append(score)\n    top_scores = sorted(scores, reverse=True)[:3]\n    return top_scores\n\ndemo = gr.Interface(\n    track_score, \n    gr.Number(label=\"Score\"), \n    gr.JSON(label=\"Top Scores\")\n)\ndemo.launch()\n</code></pre></div>\n\n<p>In the code above, the <code>scores</code> array is shared between all users. If multiple users are accessing this demo, their scores will all be added to the same list, and the returned top 3 scores will be collected from this shared reference. </p>\n\n<h2 id=\"session-state\">Session State</h2>\n\n<p>Another type of data persistence Gradio supports is session <strong>state</strong>, where data persists across multiple submits within a page session. However, data is <em>not</em> shared between different users of your model. To store data in a session state, you need to do three things:</p>\n\n<ol>\n<li>Pass in an extra parameter into your function, which represents the state of the interface.</li>\n<li>At the end of the function, return the updated value of the state as an extra return value.</li>\n<li>Add the <code>'state'</code> input and <code>'state'</code> output components when creating your <code>Interface</code></li>\n</ol>\n\n<p>A chatbot is an example where you would need session state - you want access to a users previous submissions, but you cannot store chat history in a global variable, because then chat history would get jumbled between different users. </p>\n\n<div class='codeblock'><pre><code class='lang-python'>import gradio as gr\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\nimport torch\n\ntokenizer = AutoTokenizer.from_pretrained(\"microsoft/DialoGPT-medium\")\nmodel = AutoModelForCausalLM.from_pretrained(\"microsoft/DialoGPT-medium\")\n\n\ndef user(message, history):\n    return \"\", history + [[message, None]]\n\n\ndef bot(history):\n    user_message = history[-1][0]\n    new_user_input_ids = tokenizer.encode(\n        user_message + tokenizer.eos_token, return_tensors=\"pt\"\n    )\n\n    # append the new user input tokens to the chat history\n    bot_input_ids = torch.cat([torch.LongTensor([]), new_user_input_ids], dim=-1)\n\n    # generate a response\n    response = model.generate(\n        bot_input_ids, max_length=1000, pad_token_id=tokenizer.eos_token_id\n    ).tolist()\n\n    # convert the tokens to text, and then split the responses into lines\n    response = tokenizer.decode(response[0]).split(\"<|endoftext|>\")\n    response = [\n        (response[i], response[i + 1]) for i in range(0, len(response) - 1, 2)\n    ]  # convert to tuples of list\n    history[-1] = response[0]\n    return history\n\n\nwith gr.Blocks() as demo:\n    chatbot = gr.Chatbot()\n    msg = gr.Textbox()\n    clear = gr.Button(\"Clear\")\n\n    msg.submit(user, [msg, chatbot], [msg, chatbot], queue=False).then(\n        bot, chatbot, chatbot\n    )\n    clear.click(lambda: None, None, chatbot, queue=False)\n\ndemo.launch()\n\n</code></pre></div>\n\n<p><gradio-app space='gradio/chatbot_dialogpt'></gradio-app></p>\n\n<p>Notice how the state persists across submits within each page, but if you load this demo in another tab (or refresh the page), the demos will not share chat history. </p>\n\n<p>The default value of <code>state</code> is None. If you pass a default value to the state parameter of the function, it is used as the default value of the state instead. The <code>Interface</code> class only supports a single input and outputs state variable, though it can be a list with multiple elements. For more complex use cases, you can use Blocks, <a rel=\"noopener\" target=\"_blank\" href=\"/guides/state-in-blocks/\">which supports multiple <code>State</code> variables</a>.</p>\n", "tags": [], "spaces": [], "url": "/guides/interface-state/", "contributor": null}}